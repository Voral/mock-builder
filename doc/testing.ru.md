# Тестирование с использованием трейта `MockTools`

Трейт `MockTools` предоставляет инструменты для управления поведением моков во время тестирования. Он особенно полезен в
случаях, когда тестируемый код не поддерживает внедрение зависимостей (Dependency Injection), и классы используются
внутри других классов напрямую. В таких ситуациях моки позволяют контролировать поведение этих внутренних классов.

В этой статье мы рассмотрим, как использовать трейт `MockTools` для написания тестов с помощью PHPUnit, а также упомянем
случаи, где он наиболее эффективен.

---

## Основные возможности трейта `MockTools`

1. **Настройка возвращаемых значений:**
    - Вы можете задать фиксированные значения, которые будут возвращаться при вызове метода.
    - Поддерживается режим по умолчанию (default) и режим с именованными параметрами.

2. **Выброс исключений:**
    - Можно настроить метод так, чтобы он выбрасывал исключение при определённых вызовах.

3. **Проверка параметров:**
    - После выполнения теста можно проверить, какие параметры были переданы в метод.

4. **Счётчик вызовов:**
    - Трейт отслеживает количество вызовов каждого метода.

---

## Пример использования

### 1. Настройка мока

Допустим, у нас есть класс `UserService`, который мы хотим протестировать:

```php
<?php

namespace App;

class UserService
{
    public function getUser(int $id): array
    {
        return self::executeMocked(__FUNCTION__, func_get_args());
    }
}
```

Метод `getUser` использует `self::executeMocked`, что позволяет нам управлять его поведением через трейт `MockTools`.

---

### 2. Написание теста

Ниже приведён пример теста с использованием PHPUnit:

```php
<?php

use App\UserService;
use PHPUnit\Framework\TestCase;

class UserServiceTest extends TestCase
{
    protected UserService $userService;

    protected function setUp(): void
    {
        $this->userService = new UserService();

        // Настройка мока
        UserService::cleanMockData(
            'getUser',
            results: [
                ['id' => 1, 'name' => 'John Doe'], // Первый вызов
                ['id' => 2, 'name' => 'Jane Doe'], // Второй вызов
            ],
            defaultResult: ['id' => 0, 'name' => 'Unknown'], // Результат по умолчанию
        );
    }

    public function testGetUser(): void
    {
        // Первый вызов
        $result = $this->userService->getUser(1);
        $this->assertEquals(['id' => 1, 'name' => 'John Doe'], $result);

        // Второй вызов
        $result = $this->userService->getUser(2);
        $this->assertEquals(['id' => 2, 'name' => 'Jane Doe'], $result);

        // Третий вызов (возвращается значение по умолчанию)
        $result = $this->userService->getUser(3);
        $this->assertEquals(['id' => 0, 'name' => 'Unknown'], $result);

        // Проверка количества вызовов
        $this->assertEquals(3, UserService::getMockedCounter('getUser'));

        // Проверка параметров первого вызова
        $params = UserService::getMockedParams('getUser', 0);
        $this->assertEquals([1], $params);
    }

    public function testExceptionHandling(): void
    {
        // Настройка мока для выброса исключения
        UserService::cleanMockData(
            'getUser',
            exceptions: [new \InvalidArgumentException('Invalid user ID')],
        );

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('Invalid user ID');

        // Вызов метода, который выбросит исключение
        $this->userService->getUser(999);
    }
}
```

---

### 3. Объяснение кода

1. **Настройка мока (`cleanMockData`):**
    - Метод `cleanMockData` используется для задания поведения мока.
    - Параметр `results` определяет последовательность возвращаемых значений.
    - Параметр `defaultResult` задаёт значение, которое будет возвращаться, если все значения из `results` уже
      использованы.
    - Параметр `exceptions` позволяет настроить выброс исключений при вызове метода.

2. **Проверка результатов:**
    - `$this->assertEquals` используется для сравнения ожидаемого и фактического результата.
    - `$this->expectException` проверяет, что метод выбрасывает ожидаемое исключение.

3. **Проверка параметров:**
    - Метод `getMockedParams` возвращает параметры, переданные в конкретный вызов метода.
    - Индекс `0` соответствует первому вызову, `1` — второму и т.д.

4. **Счётчик вызовов:**
    - Метод `getMockedCounter` возвращает общее количество вызовов метода.

---

## Именованный режим

Именованный режим полезен, когда поведение метода должно зависеть от передаваемых параметров. Например, если метод
вызывается с разными аргументами, и вы хотите настроить уникальное поведение для каждого набора параметров.

Для этого используется метод `paramHash`, который создаёт хеш на основе переданных параметров. Этот хеш используется как
ключ для выбора результата.

### Пример использования именованного режима

```php
// Настройка мока с именованным режимом
UserService::cleanMockData(
    'getUser',
    results: [
        UserService::paramHash([1]) => ['id' => 1, 'name' => 'John Doe'],
        UserService::paramHash([2]) => ['id' => 2, 'name' => 'Jane Doe'],
    ],
    namedMode: true,
);

// Тестирование
public function testNamedMode(): void
{
    $result = $this->userService->getUser(1);
    $this->assertEquals(['id' => 1, 'name' => 'John Doe'], $result);

    $result = $this->userService->getUser(2);
    $this->assertEquals(['id' => 2, 'name' => 'Jane Doe'], $result);

    // Проверка, что метод не найдёт подходящего результата для неизвестного параметра
    $result = $this->userService->getUser(3);
    $this->assertNull($result);
}
```

### Решаемая проблема

Именованный режим особенно полезен, когда:

- Метод вызывается с разными параметрами, и нужно настроить уникальное поведение для каждого набора параметров.
- В тестируемом коде нет Dependency Injection, и классы используются внутри других классов напрямую. В таких случаях
  невозможно заменить реальные объекты на моки стандартными средствами PHPUnit.

---

## Заключение

Трейт `MockTools` значительно упрощает тестирование классов, предоставляя гибкие инструменты для управления поведением
моков. Особенно он полезен в случаях, когда тестируемый код не поддерживает внедрение зависимостей, и классы
используются внутри других классов.

Используйте примеры из этой статьи как основу для написания собственных тестов с помощью PHPUnit.