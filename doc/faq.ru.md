# Часто задаваемые вопросы (FAQ)

## Оглавление

1. [Как быть с классами в глобальном пространстве имён?](#как-быть-с-классами-в-глобальном-пространстве-имён)

---

### Как быть с классами в глобальном пространстве имён?

Утилита поддерживает обработку классов, которые находятся в глобальном пространстве имён (без `namespace`). Однако,
такие классы требуют особого подхода для автозагрузки, так как стандарт PSR-4 не поддерживает классы без пространства
имён.

#### Решение: Использование кастомного автолоадера

Для загрузки классов из глобального пространства имён можно создать собственный автолоадер. Вот пример реализации:

```php
// custom_autoloader.php
spl_autoload_register(function ($class) {
    // Проверяем, что класс находится в глобальном пространстве имён
    if (false === strpos($class, '\\')) {
        $filePath = __DIR__ . '/target/' . $class . '.php';
        if (file_exists($filePath)) {
            require_once $filePath;
        }
    }
});
```

#### Подключение автолоадера

Чтобы автолоадер работал, его нужно подключить в файле инициализации вашего приложения (например, `bootstrap.php`):

```php
// bootstrap.php
require_once __DIR__ . '/custom_autoloader.php';
```

#### Примечания

1. **Конфликты имён файлов**:
    - Если у вас есть несколько классов с одинаковыми именами в глобальном пространстве имён, это может привести к
      конфликтам при автозагрузке.
    - Утилита сохраняет такие классы в каталог `/target/`, но пользователь должен самостоятельно решать возможные
      конфликты, например, переименовывая файлы или классы.

2. **Альтернатива: секция `"files"` в `composer.json`**:
    - Если количество глобальных классов невелико, их можно явно перечислить в секции `"files"` файла `composer.json`:
      ```json
      {
          "autoload": {
            "files": [
              "target/GlobalClass.php",
              "target/AnotherClass.php"
          ]
        }
      }
      ```
