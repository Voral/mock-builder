# Часто задаваемые вопросы (FAQ)

## Оглавление

1. [Как быть с классами в глобальном пространстве имён?](#как-быть-с-классами-в-глобальном-пространстве-имён)
2. [Как создавать моки для функций в глобальной области видимости?](#как-создавать-моки-для-функций-в-глобальной-области-видимости)

---

### Как быть с классами в глобальном пространстве имён?

Утилита поддерживает обработку классов, которые находятся в глобальном пространстве имён (без `namespace`). Однако,
такие классы требуют особого подхода для автозагрузки, так как стандарт PSR-4 не поддерживает классы без пространства
имён.

#### Решение: Использование кастомного автолоадера

Для загрузки классов из глобального пространства имён можно создать собственный автолоадер. Вот пример реализации:

```php
// custom_autoloader.php
spl_autoload_register(function ($class) {
    // Проверяем, что класс находится в глобальном пространстве имён
    if (false === strpos($class, '\\')) {
        $filePath = __DIR__ . '/target/' . $class . '.php';
        if (file_exists($filePath)) {
            require_once $filePath;
        }
    }
});
```

#### Подключение автолоадера

Чтобы автолоадер работал, его нужно подключить в файле инициализации вашего приложения (например, `bootstrap.php`):

```php
// bootstrap.php
require_once __DIR__ . '/custom_autoloader.php';
```

#### Примечания

1. **Конфликты имён файлов**:
    - Если у вас есть несколько классов с одинаковыми именами в глобальном пространстве имён, это может привести к
      конфликтам при автозагрузке.
    - Утилита сохраняет такие классы в каталог `/target/`, но пользователь должен самостоятельно решать возможные
      конфликты, например, переименовывая файлы или классы.

2. **Альтернатива: секция `"files"` в `composer.json`**:
    - Если количество глобальных классов невелико, их можно явно перечислить в секции `"files"` файла `composer.json`:
      ```json
      {
          "autoload": {
            "files": [
              "target/GlobalClass.php",
              "target/AnotherClass.php"
          ]
        }
      }
      ```

---

### **Как создавать моки для функций в глобальной области видимости?**

Утилита не поддерживает автоматическую генерацию моков для функций в глобальной области видимости, так как PHP не
позволяет переопределять функции напрямую. Однако вы можете легко создавать моки для таких функций, используя
сгенерированный класс `MockFunctions`. Этот класс уже включает трейт `MockTools` и предоставляет готовый инструмент для
управления поведением моков.

#### 1. Используйте сгенерированный класс `MockFunctions`

При генерации моков утилита автоматически создаёт класс `MockFunctions` в пространстве имён `\Mocker`. Этот класс
использует трейт `MockTools` и готов к использованию для создания моков глобальных функций.

Пример класса `MockFunctions`:

```php
namespace App\Mocker;

class MockFunctions {
    use MockTools;
}
```

#### 2. Создайте файл с моками для глобальных функций

Создайте отдельный файл (например, `test/function_mock.php`), в котором определите моки для нужных функций. Реализуйте
каждую функцию так, чтобы она вызывала соответствующий метод класса `MockFunctions`. Например:

```php
function GetMessage(string $messageCode, array $replace = [], $language = null): string {
    return \App\Mocker\MockFunctions::executeMocked('GetMessage', [$messageCode, $replace, $language]);
}
```

Этот подход позволяет заменить реальные функции их моками, сохраняя контроль над их поведением.

#### 3. Пример тестируемого класса

Предположим, у вас есть класс, который использует глобальную функцию `GetMessage`:

```php
namespace App;

class A {
    public static function foo(): string {
        return GetMessage('test1') . GetMessage('test2');
    }
}
```

#### 4. Напишите тест

Теперь вы можете написать тест, настраивающий поведение мока для функции `GetMessage`:

```php
<?php

declare(strict_types=1);

namespace App;

use App\Mocker\MockFunctions;
use PHPUnit\Framework\TestCase;

/**
 * @internal
 *
 * @coversNothing
 */
final class ATest extends TestCase {
    public function testFoo(): void {
        // Настройка поведения мока по умолчанию
        $definition = new MockDefinition(result: 'test');
        // Настройка мока для функции GetMessage
        MockFunctions::cleanMockData('GetMessage', defaultDefinition: $definition);

        // Вызов тестируемого метода
        $result = A::foo();

        // Проверка результата
        self::assertSame('testtest', $result);

        // Проверка количества вызовов функции
        self::assertSame(2, MockFunctions::getMockedCounter('GetMessage'));

        // Проверка параметров вызовов
        $params = MockFunctions::getMockedParamsAll('GetMessage');
        self::assertSame('test1', $params[0][0]); // Первый вызов с параметром 'test1'
        self::assertSame('test2', $params[1][0]); // Второй вызов с параметром 'test2'
    }
}
```

#### Примечания

1. **Автоматическая генерация класса `MockFunctions`:**
    - Утилита автоматически создаёт класс `MockFunctions` в процессе генерации моков. Этот класс уже включает
      трейт `MockTools` и готов к использованию.
    - Убедитесь, что файл с моками загружается перед выполнением тестируемого кода (например, через автозагрузку или
      явное подключение файла).

2. **Изоляция тестов:**
    - Используйте метод `cleanMockData` для очистки состояния моков перед каждым тестом, чтобы избежать побочных
      эффектов.

3. **Гибкость настройки:**
    - Вы можете настраивать поведение моков, указывая предопределённые результаты, исключения или значения по умолчанию.
    - Также можно отслеживать объект, вызвавший функцию, используя метод `getMockedEntity`.
